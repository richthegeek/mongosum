// Generated by CoffeeScript 1.3.3
(function() {
  var Collection, DB, Server, collection_name, get_schema, merge_schema, walk_objects,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Server = require('mongolian');

  DB = require('mongolian/lib/db.js');

  Collection = require('mongolian/lib/collection.js');

  collection_name = 'schemas';

  Server.prototype.db = function(name) {
    if (!(this._dbs[name] != null)) {
      this._dbs[name] = new DB(this, name);
      this._dbs[name].schema = new Collection(this._dbs[name], collection_name);
    }
    return this._dbs[name];
  };

  DB.prototype.collection = function(name) {
    return this._collections[name] || (this._collections[name] = new Collection(this, name));
  };

  /*
  # Retrieve the schema for this collection
  */


  Collection.prototype.getSchema = function(callback) {
    var criteria;
    if (this.name === collection_name) {
      throw 'MongoSum cannot get the schema of the schemas collection.';
    }
    criteria = {
      _collection: this.name
    };
    return this.db.schema.find(criteria).next(function(err, schema) {
      if (schema == null) {
        schema = {};
      }
      return callback(err, schema);
    });
  };

  /*
  # Set the schema for this collection (used internally)
  */


  Collection.prototype.setSchema = function(schema, callback) {
    var criteria;
    if (this.name === collection_name) {
      throw 'MongoSum cannot set the schema of the schemas collection';
    }
    criteria = {
      _collection: this.name
    };
    schema._collection = this.name;
    return this.db.schema.update(criteria, schema, true, callback);
  };

  /*
  # Do a full-table update of the schema. This is expensive.
  */


  Collection.prototype.updateSchema = function(callback) {
    var each, schema;
    schema = {};
    each = function(err, object) {
      return merge_schema(schema, get_schema(object));
    };
    return this.find().forEach(each, function() {
      console.log(schema);
      return this.setSchema(schema, callback);
    });
  };

  /*
  # INTERNAL. Merge schema, save it, and fire the callback.
  */


  Collection.prototype._merge_schemas = function(err, data, callback, options, schema, schema_change_count) {
    var _this = this;
    if (schema_change_count > 0) {
      return this.getSchema(function(err, full_schema) {
        full_schema = merge_schema(full_schema, schema, options);
        return _this.setSchema(full_schema, function() {
          return callback && callback(err, data);
        });
      });
    } else {
      return callback && callback(err, data);
    }
  };

  Collection.prototype._insert = Collection.prototype.insert;

  Collection.prototype.insert = function(object, callback) {
    var complete, obj, schema, schema_change_count, update_schema, _i, _len, _ref, _results,
      _this = this;
    if (this.name === collection_name) {
      return Collection.prototype._insert.apply(this, arguments);
    }
    _ref = [{}, 0], schema = _ref[0], schema_change_count = _ref[1];
    update_schema = function(err, data) {
      if (!err) {
        schema_change_count++;
        return merge_schema(schema, get_schema(data));
      }
    };
    if (Object.prototype.toString.call(object) !== '[object Array]') {
      object = [object];
    }
    complete = 0;
    _results = [];
    for (_i = 0, _len = object.length; _i < _len; _i++) {
      obj = object[_i];
      _results.push(this._insert(obj, function(err, data) {
        update_schema(err, data);
        if (++complete === object.length) {
          return _this._merge_schemas(err, data, callback, {}, schema, schema_change_count);
        }
      }));
    }
    return _results;
  };

  Collection.prototype._update = Collection.prototype.update;

  Collection.prototype.update = function(criteria, object, upsert, multi, callback) {
    var merge_opts, options, schema, schema_change_count, subtract_schema, update_schema, _ref,
      _this = this;
    if (this.name === collection_name) {
      return Collection.prototype._update.apply(this, arguments);
    }
    if (!callback && typeof multi === 'function') {
      callback = multi;
      multi = false;
    }
    if (!callback && typeof upsert === 'function') {
      callback = upsert;
      upsert = false;
    }
    if (callback && typeof callback !== 'function') {
      throw 'Callback is not a function!';
    }
    _ref = [{}, 0], schema = _ref[0], schema_change_count = _ref[1];
    subtract_schema = function(err, data) {
      if (!err && data) {
        return merge_schema(schema, get_schema(data), {
          sum: function(a, b) {
            return (b === null && -a) || (a - b);
          },
          min: function(a, b) {
            return a;
          },
          max: function(a, b) {
            return a;
          }
        });
      }
    };
    update_schema = function(err, data) {
      if (!err && data) {
        schema_change_count++;
        return merge_schema(schema, get_schema(data));
      }
    };
    if (Object.prototype.toString.call(object) !== '[object Array]') {
      object = [object];
    }
    if (multi !== true) {
      object = [object.shift()];
    }
    options = {
      remove: false,
      "new": true,
      upsert: !!upsert
    };
    merge_opts = {
      min: function(a, b) {
        if (isNaN(parseInt(a)) || (b === a)) {
          throw 'FULL UPDATE';
        }
        return Math.min(a, b);
      },
      max: function(a, b) {
        if (isNaN(parseInt(a)) || (b === a)) {
          throw 'FULL UPDATE';
        }
        return Math.max(a, b);
      }
    };
    return this.find(criteria).toArray(function(err, _originals) {
      var complete, for_merge, o, obj, opts, originals, _i, _j, _len, _len1, _results;
      if (_originals == null) {
        _originals = [];
      }
      originals = {};
      for (_i = 0, _len = _originals.length; _i < _len; _i++) {
        o = _originals[_i];
        originals[o._id.toString()] = o;
      }
      for_merge = [];
      complete = 0;
      _results = [];
      for (_j = 0, _len1 = object.length; _j < _len1; _j++) {
        obj = object[_j];
        opts = {
          criteria: criteria,
          update: obj,
          options: options,
          remove: false,
          "new": true,
          upsert: !!upsert
        };
        _results.push(_this.findAndModify(opts, function(err, data) {
          var _k, _len2;
          if (!err && data) {
            subtract_schema(err, originals[data._id.toString()]);
            if (!err) {
              for_merge.push(data);
            }
            if (++complete === object.length) {
              try {
                for (_k = 0, _len2 = for_merge.length; _k < _len2; _k++) {
                  data = for_merge[_k];
                  update_schema(null, data);
                }
                return _this._merge_schemas(err, data, callback, merge_opts, schema, schema_change_count);
              } catch (e) {
                if (e === 'FULL UPDATE') {
                  return _this.updateSchema(callback);
                } else {
                  throw e;
                }
              }
            }
          }
        }));
      }
      return _results;
    });
  };

  Collection.prototype._remove = Collection.prototype.remove;

  Collection.prototype.remove = function(criteria, callback) {
    var merge_opts, schema, subtract_schema,
      _this = this;
    if (!callback && typeof criteria === 'function') {
      callback = criteria;
      criteria = {};
    }
    schema = {};
    subtract_schema = function(err, data) {};
    if (!err && data) {
      merge_schema(schema, get_schema(data), {
        sum: function(a, b) {
          return (b === null && -a) || (a - b);
        },
        min: function(a, b) {
          return a;
        },
        max: function(a, b) {
          return a;
        }
      });
    }
    merge_opts = {
      min: function(a, b) {
        if (isNaN(parseInt(a)) || (b === a)) {
          throw 'FULL UPDATE';
        }
        return Math.min(a, b);
      },
      max: function(a, b) {
        if (isNaN(parseInt(a)) || (b === a)) {
          throw 'FULL UPDATE';
        }
        return Math.max(a, b);
      }
    };
    return this.find(criteria).toArray(function(err, data) {
      var row, _i, _len;
      data = data || [];
      for (_i = 0, _len = data.length; _i < _len; _i++) {
        row = data[_i];
        subtract_schema(err, row);
      }
      try {
        if (data.length > 0) {
          _this._merge_schemas(err, data, (function() {
            return null;
          }), merge_opts, schema, 1);
        }
        return _this._remove(criteria, callback);
      } catch (e) {
        if (e === 'FULL UPDATE') {
          return _this.updateSchema(callback);
        } else {
          throw e;
        }
      }
    });
  };

  get_schema = function(object) {
    return walk_objects(object, {}, function(key, vals, types) {
      var ret;
      ret = {};
      ret.type = types[0];
      ret.example = vals[0];
      if (types[0] === 'Number' || (vals[0] = parseInt(vals[0], 10))) {
        ret.min = ret.max = ret.sum = vals[0];
      }
      return ret;
    });
  };

  merge_schema = function(left, right, options) {
    var _ref, _ref1, _ref2;
    if (options == null) {
      options = {};
    }
    if ((_ref = options.sum) == null) {
      options.sum = function(a, b) {
        return (parseInt(a, 10) + parseInt(b, 10)) || a;
      };
    }
    if ((_ref1 = options.min) == null) {
      options.min = Math.min;
    }
    if ((_ref2 = options.max) == null) {
      options.max = Math.max;
    }
    return walk_objects(left, right, function(key, vals, types) {
      if (!vals[0] && vals[1]) {
        vals[0] = JSON.parse(JSON.stringify(vals[1]));
        if (vals[1].sum) {
          vals[1].sum = null;
        }
      }
      if ((vals[0] != null) && vals[0].type) {
        if (vals[0].type === 'Number' && vals[1].type === 'Number') {
          vals[0].min = options.min(vals[0].min, vals[1].min);
          vals[0].max = options.max(vals[0].max, vals[1].max);
          vals[0].sum = options.sum(vals[0].sum, vals[1].sum);
        }
        vals[0].example = (vals[1] && vals[1].example) || vals[0].example;
      }
      return vals[0];
    });
  };

  walk_objects = function(first, second, fn) {
    var ignore, k, key, keys, type, v, v1, v2, _i, _j, _len, _len1, _ref;
    if (second == null) {
      second = {};
    }
    keys = (function() {
      var _results;
      _results = [];
      for (k in first) {
        v = first[k];
        _results.push(k);
      }
      return _results;
    })();
    for (k in second) {
      v = second[k];
      if (__indexOf.call(keys, k) < 0) {
        keys.push(k);
      }
    }
    ignore = ['_c', '_h', '_id', '_t'];
    for (_i = 0, _len = keys.length; _i < _len; _i++) {
      key = keys[_i];
      if (!(__indexOf.call(ignore, key) < 0)) {
        continue;
      }
      v1 = first[key];
      v2 = second[key];
      type = function(o) {
        return ((o != null) && o.constructor && o.constructor.name) || 'Null';
      };
      if (((_ref = type(v1)) === 'Object' || _ref === 'Array') && !(v1.type != null)) {
        first[key] = walk_objects(v1, v2, fn);
      } else {
        first[key] = fn(key, [v1, v2], [type(v1), type(v2)]);
      }
    }
    for (_j = 0, _len1 = ignore.length; _j < _len1; _j++) {
      key = ignore[_j];
      if (first && first[key]) {
        delete first[key];
      }
    }
    return first;
  };

  module.exports = Server;

}).call(this);
